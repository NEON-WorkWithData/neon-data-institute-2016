---
title: "Untitled"
author: "Kyla Dahlin"
date: "May 3, 2016"
output: html_document
---



First, let's load the required libraries.

```{r load-libraries, warning=FALSE, results='hide', message=FALSE}
# load libraries
library(raster)
library(rhdf5)
library(rgdal)

setwd("~/Documents/data/1_data-institute-2016")
```


We've already created some functions to work with HSI data. Let's import them.

we can also import into RMD
http://zevross.com/blog/2014/07/09/making-use-of-external-r-code-in-knitr-and-r-markdown/

The first thing that we can do is load the functions that we want to use into
our environment! This makes it easy to quickly access these functions without
having to retype the function code each time. This also makes it easy to maintain
function code in just ONE PLACE! 

```{r import-h5-functions }

# your file will be in your working directory! This one happens to be in a diff dir
# than our data

source("/Users/lwasser/Documents/GitHub/neon-data-institute-2016/_posts/institute-materials/day1_monday/import-HSIH5-functions.R")
```

Once we have imported the functions, we can use them to explore our data.

```{r}

# note: plotting to look at things as you go is always recommmended!
  
# first we read in the LiDAR data

# dsm = digital surface model == top of canopy
dsm <- raster("Teakettle/may1_subset/lidar/Teak_lidarDSM.tif")
# dtm = digital terrain model = elevation
dtm <- raster("Teakettle/may1_subset/lidar/Teak_lidarDTM.tif") 

# rename to CHM
veg.ht <- dsm - dtm

plot(veg.ht,
     main="Canopy Height, \nTeakettle Site California") # do the numbers look reasonable? 60 m is tall for a tree, but
             # this is Ponderosa pine territory (I think), so not out of the question.

```

## Explore Veg Height data

Have a close look at the veg height values. Do they seem reasonable?

## Create LiDAR Raster Brick

Next, we can stack the rasters together to create a brick.

```{r create-stack }
# for simplicity later let's stack these rasters together
# 
lidar.brick <- brick(dsm, dtm, veg.ht)

```

next, let's read in HSI data.

```{r read-band-83 }

# first identify the file of interest
f <- "Teakettle/may1_subset/spectrometer/Subset3NIS1_20130614_100459_atmcor.h5"
# then id the projection code
# define the CRS definition by EPSG code
epsg <- 32611

# create a list of bands
bands <- c(60,83)

# Let's read in a few spectral bands as a stack using a function
ndvi.stack <- create_stack(bands = bands,
             epsg=epsg)

# calculate ndvi
ndvi <- (ndvi.stack[[2]]-ndvi.stack[[1]]) / (ndvi.stack[[2]]+ndvi.stack[[1]])


# to calculate NDVI for the NIR let's use 793 nm, or band 83 here
# band83 <- open_band(fileName=f, bandNum = 83, epsg=epsg)
# for the red let's use 677 nm, or band 60 here
# band60 <- open_band(fileName=f, bandNum = 60, epsg=epsg)
# calculate NDVI!
# ndvi <- (band83 - band60)/(band83+band60)

# overlay the two to see that they line up (note we're assuming someone else has
# done the heavy lifting of making sure these are nearly perfectly aligned)
plot(veg.ht,
     main="Vegetation at Teakettle Field Site")
plot(ndvi, 
     add = T, 
     col = rainbow(255),
     alpha=.8)

# now let's crop the lidar data to the HSI data
lidar.crop <- crop(lidar.brick, extent(ndvi))

# and brick them all together
all.data <- brick(ndvi, lidar.crop)
```

## Considering Slope & Aspect

OK! Now we're going to test a simple hypothesis. 

Because California is 

* dry, 
In the northern hemisphere

We may expect to find taller, greener vegetation on north facing slopes than on 
south facing slopes. To test this we need to 

1. Calculate aspect  << we can import this
2. Isolate north and south faces, 
3. Decide what we mean by 'tall' and 'green', 
4. Isolate tall, green pixels on north & south facing slopes, 
5. look at %s for each, 
6. do a t-test to compare all pixels.

# Leah needs to crop subset data before including it so everthing lines up.

```{r import-aspect }

# (1) calculate aspect of cropped DTM

# aspect <- terrain(all.data[[3]], opt = "aspect", unit = "degrees", neighbors = 8)
aspect <- raster("Teakettle/may1_subset/lidar/Teak_lidarAspect.tif")
# crop the data to the extent of the other rasters we are working with!
aspect <- crop(aspect, extent(ndvi))

# create mask -- 
# (2) make 'dummy' (1s and 0s) layers for north facing (315 deg to 45 deg) and
# south facing (135 deg to 225 deg) slopes

# the other option is to create a CLASSIFIED RASTER
# if that is classified than you can have a nice intermediate raster

# all values larger than 315 and less than 45 are north facing
north.facing <- aspect >= 315 | aspect <= 45
# all values bewteen 135 and 225 are south facing
south.facing <- aspect >= 135 & aspect <= 225

north.facing[north.facing == 0] <- NA
south.facing[south.facing == 0] <- NA

```

Now we want to determine what defines "talll" and "Green"

```{r}
# (3) to choose what we mean by 'tall' and 'green' let's look at some histograms
# and descriptive stats(of the whole dataset, we don't want to bias our results 
# too much!)

# histogram of tree ht
hist(all.data[[4]])

# it's hard to tell here where the data maxes out, so we can calc the actual max
# but to do that without converting our raster to a vector, we use 'cellStats'

ht.max <- cellStats(all.data[[4]], max)

# and some more exploration - even though this is a very skewed data set...
ht.mean <- cellStats(all.data[[4]], mean)
ht.sd <- cellStats(all.data[[4]], sd)

# so let's be semi-robust and call 'tall' trees those with mean + 1 sd
tall.def <- ht.mean + ht.sd
```

Next, look at NDVI.

# KYLA - would taking the 3rd quartile be ok here? 
```{r explore-ndvi}
# now let's look at ndvi
hist(all.data[[1]])

# this is a nice bimodal data set, so let's just take the top 1/3 of the data
# could take the 3rd quartile
# do this using summary stats
stats <- summary(all.data[[1]])
stats[["3rd Qu.",1]]

# or manually calculate this
green.range <- cellStats(all.data[[1]], max) - cellStats(all.data[[1]], min)
green.def <- cellStats(all.data[[1]], max) - (green.range/3)


# (4) compare fractions of tall & green on north and south facing slopes (since
# our pixels are 1x1 m we can just use counts of pixels and not worry about area)

north.count <- cellStats(north.facing, sum, na.rm = T)
south.count <- cellStats(south.facing, sum, na.rm = T)

# note there's way more south facing area in this image than north facing

north.tall.green <- north.facing == 1 & all.data[[1]] >= green.def & 
  all.data[[4]] >= tall.def

north.tall.green.count <- cellStats(north.tall.green, sum)

south.tall.green <- south.facing == 1 & all.data[[1]] >= green.def & 
  all.data[[4]] >= tall.def

south.tall.green.count <- cellStats(south.tall.green, sum)

north.tall.green.frac <- north.tall.green.count/north.count
south.tall.green.frac <- south.tall.green.count/south.count

# if we look at these fracs, >11% of the pixels on north facing slopes should
# meet our tall and green criteria, while <6% of the pixels on south facing
# slopes do. So that's reassuring. (using original data set)

# before moving on, let's make a map to see what this looks like on the ground
# first read in a green band so we can make a color infrared RGB image - let's 
# use ~550 nm here, or band 35

band35 <- open_band(fileName=f, bandNum = 35, epsg=epsg)

# open a window to make a bigger map (this is different on a mac?)
x11()

# brick the bands and get rid of values >1
CIR <- brick(band83, band60, band35)
CIR[CIR > 1] <- NA

# turn your tall north and south 1/0 layers into 1/NA so NAs are transparent

north.tall.green[north.tall.green == 0] <- NA
south.tall.green[south.tall.green == 0] <- NA


plotRGB(CIR, scale = 1, stretch = "lin")
plot(north.tall.green, col = "cyan", add = T, legend = F)
plot(south.tall.green, col = "blue", add = T, legend = F)

# two side notes: I (Kyla) really don't like using R to make maps - I usually
# export tifs and pull them into a real mapping program like Arc or QGIS for 
# actual cartography. R is just a bit clunky, especially for legends, etc.
# also, note here that there are clusters where 'south facing' and 'north facing'
# pixels are very close together - this is due to the very fine resolution of the
# topo data. One might want to either smooth this data (low-pass filter) or
# use a larger kernel to calculate slope (not possible with the terrain fxn in
# the raster package)

```
```{r run-stats}
# (5) let's do some stats! t-test and boxplots of veg height and greenness 
# distributions in north versus south facing parts of scene.

# let's start with NDVI - isolate NDVI on north and south facing slopes

north.NDVI <- all.data[[1]] * north.facing
south.NDVI <- all.data[[1]] * south.facing

# now let's do veg height
north.veght <- all.data[[4]] * north.facing
south.veght <- all.data[[4]] * south.facing

# now to do more complicated non-spatial stats in R we need to convert our
# raster data to vectors - for this example the spatial distribution of the
# data doesn't matter.

north.NDVI.vec <- getValues(north.NDVI)
south.NDVI.vec <- getValues(south.NDVI)

north.veght.vec <- getValues(north.veght)
south.veght.vec <- getValues(south.veght)

# and get rid of NAs for simplicity (the above vectors are all the same length
# and include all the cells in the original dataset)

north.NDVI.vec <- north.NDVI.vec[!is.na(north.NDVI.vec)]
south.NDVI.vec <- south.NDVI.vec[!is.na(south.NDVI.vec)]

# now let's make a data frame with a north versus south column
aspect.NDVI <- c(rep("north", length(north.NDVI.vec)), 
                 rep("south", length(south.NDVI.vec)))
aspect.NDVI <- as.factor(aspect.NDVI)

NDVI.vec <- c(north.NDVI.vec, south.NDVI.vec)

# this (below) is clunky - I thought I could use cbind but 'factors' are getting the 
# best of me
NDVI.dat <- as.data.frame(matrix(NA, nrow = length(NDVI.vec), ncol = 2))
names(NDVI.dat) <- c("aspect", "NDVI")
NDVI.dat[,1] <- aspect.NDVI
NDVI.dat[,2] <- NDVI.vec
boxplot(NDVI ~ aspect, data = NDVI.dat, col = "cornflowerblue", main = "NDVI 
        on North versus South facing slopes")

# and now a t-test - note that since these aren't normally distributed, this
# might not be the best approach, but ok for a quick assessment.
NDVI.ttest <- t.test(north.NDVI.vec, south.NDVI.vec, alternative = "greater")



# and now for veg height
north.veght.vec <- north.veght.vec[!is.na(north.veght.vec)]
south.veght.vec <- south.veght.vec[!is.na(south.veght.vec)]

# now let's make a data frame with a north versus south column
aspect.veght <- c(rep("north", length(north.veght.vec)), 
                 rep("south", length(south.veght.vec)))
aspect.veght <- as.factor(aspect.veght)

veght.vec <- c(north.veght.vec, south.veght.vec)

veght.dat <- as.data.frame(matrix(NA, nrow = length(veght.vec), ncol = 2))
names(veght.dat) <- c("aspect", "veght")
veght.dat[,1] <- aspect.veght
veght.dat[,2] <- veght.vec
boxplot(veght ~ aspect, data = veght.dat, col = "aquamarine4", main = "Veg Ht 
        on North versus South facing slopes")

# same caution as above!
veght.ttest <- t.test(north.veght.vec, south.veght.vec, alternative = "greater")



