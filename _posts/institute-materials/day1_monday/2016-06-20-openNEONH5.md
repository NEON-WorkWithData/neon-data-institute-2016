---
layout: post
title: "Work with Hyperspectral Remote Sensing data in R -  HDF5"
date:   2016-06-20
authors: [Leah A. Wasser, Kyla Dahlin]
contributors: []
time: "1:00 pm"
dateCreated:  2016-05-01
lastModified: 2016-05-06
packagesLibraries: [rhdf5]
categories: [self-paced-tutorial]
mainTag: tabular-time-series
tags: [R, HDF5]
tutorialSeries: [institute-day1]
description: "Learn how to open a NEON HDF5 file in R."
code1: openNEONH5.R
image:
  feature: 
  credit: 
  creditlink:
permalink: /R/intro-hdf5-R/
comments: false
---

First, let's load the required libraries.



## Explore File
Next, define the file name and view the contents quickly.


    # define the file name as an object
    f <- "spectrometer/Subset3NIS1_20130614_100459_atmcor.h5"
    
    # view the structure of the file
    # reflectance is where the refl data are stored. 
    # map info contains the proj information in WKT format
    # H5close()
    h5ls(f, all = TRUE)

    ##    group                                 name         ltype corder_valid
    ## 0      /                     ATCOR_Input_File H5L_TYPE_HARD        FALSE
    ## 1      /                 ATCOR_Processing_Log H5L_TYPE_HARD        FALSE
    ## 2      /                Aerosol Optical Depth H5L_TYPE_HARD        FALSE
    ## 3      /                               Aspect H5L_TYPE_HARD        FALSE
    ## 4      /                          Cast Shadow H5L_TYPE_HARD        FALSE
    ## 5      / Dark Dense Vegetation Classification H5L_TYPE_HARD        FALSE
    ## 6      /                 Haze-Cloud-Water Map H5L_TYPE_HARD        FALSE
    ## 7      /                  Illumination Factor H5L_TYPE_HARD        FALSE
    ## 8      /                          Path Length H5L_TYPE_HARD        FALSE
    ## 9      /                   Processing Version H5L_TYPE_HARD        FALSE
    ## 10     /                          Reflectance H5L_TYPE_HARD        FALSE
    ## 11     /                Shadow_Processing_Log H5L_TYPE_HARD        FALSE
    ## 12     /                      Sky View Factor H5L_TYPE_HARD        FALSE
    ## 13     /               Skyview_Processing_Log H5L_TYPE_HARD        FALSE
    ## 14     /                                Slope H5L_TYPE_HARD        FALSE
    ## 15     /          Slope_Aspect_Processing_Log H5L_TYPE_HARD        FALSE
    ## 16     /                  Solar Azimuth Angle H5L_TYPE_HARD        FALSE
    ## 17     /                   Solar Zenith Angle H5L_TYPE_HARD        FALSE
    ## 18     /                    Surface Elevation H5L_TYPE_HARD        FALSE
    ## 19     /                 Visibility Index Map H5L_TYPE_HARD        FALSE
    ## 20     /                   Water Vapor Column H5L_TYPE_HARD        FALSE
    ## 21     /             coordinate system string H5L_TYPE_HARD        FALSE
    ## 22     /                       flightAltitude H5L_TYPE_HARD        FALSE
    ## 23     /                        flightHeading H5L_TYPE_HARD        FALSE
    ## 24     /                           flightTime H5L_TYPE_HARD        FALSE
    ## 25     /                                 fwhm H5L_TYPE_HARD        FALSE
    ## 26     /                             map info H5L_TYPE_HARD        FALSE
    ## 27     /              to-sensor azimuth angle H5L_TYPE_HARD        FALSE
    ## 28     /               to-sensor zenith angle H5L_TYPE_HARD        FALSE
    ## 29     /                           wavelength H5L_TYPE_HARD        FALSE
    ##    corder cset       otype num_attrs  dclass          dtype  stype rank
    ## 0       0    0 H5I_DATASET         1  STRING     HST_STRING SIMPLE    1
    ## 1       0    0 H5I_DATASET         1  STRING     HST_STRING SIMPLE    1
    ## 2       0    0 H5I_DATASET         5 INTEGER  H5T_STD_I16LE SIMPLE    3
    ## 3       0    0 H5I_DATASET         5   FLOAT H5T_IEEE_F32LE SIMPLE    3
    ## 4       0    0 H5I_DATASET         5 INTEGER   H5T_STD_I8LE SIMPLE    3
    ## 5       0    0 H5I_DATASET         6 INTEGER   H5T_STD_I8LE SIMPLE    3
    ## 6       0    0 H5I_DATASET         6 INTEGER   H5T_STD_I8LE SIMPLE    3
    ## 7       0    0 H5I_DATASET         5 INTEGER   H5T_STD_I8LE SIMPLE    3
    ## 8       0    0 H5I_DATASET         5   FLOAT H5T_IEEE_F32LE SIMPLE    3
    ## 9       0    0 H5I_DATASET         0  STRING     HST_STRING SIMPLE    1
    ## 10      0    0 H5I_DATASET         5 INTEGER  H5T_STD_I16LE SIMPLE    3
    ## 11      0    0 H5I_DATASET         1  STRING     HST_STRING SIMPLE    1
    ## 12      0    0 H5I_DATASET         5 INTEGER   H5T_STD_I8LE SIMPLE    3
    ## 13      0    0 H5I_DATASET         1  STRING     HST_STRING SIMPLE    1
    ## 14      0    0 H5I_DATASET         5   FLOAT H5T_IEEE_F32LE SIMPLE    3
    ## 15      0    0 H5I_DATASET         1  STRING     HST_STRING SIMPLE    1
    ## 16      0    0 H5I_DATASET         2   FLOAT H5T_IEEE_F32LE SIMPLE    2
    ## 17      0    0 H5I_DATASET         2   FLOAT H5T_IEEE_F32LE SIMPLE    2
    ## 18      0    0 H5I_DATASET         5   FLOAT H5T_IEEE_F32LE SIMPLE    3
    ## 19      0    0 H5I_DATASET         5 INTEGER   H5T_STD_I8LE SIMPLE    3
    ## 20      0    0 H5I_DATASET         5 INTEGER  H5T_STD_I16LE SIMPLE    3
    ## 21      0    0 H5I_DATASET         1  STRING     HST_STRING SIMPLE    1
    ## 22      0    0 H5I_DATASET         3   FLOAT H5T_IEEE_F32LE SIMPLE    1
    ## 23      0    0 H5I_DATASET         3   FLOAT H5T_IEEE_F32LE SIMPLE    1
    ## 24      0    0 H5I_DATASET         3   FLOAT H5T_IEEE_F32LE SIMPLE    1
    ## 25      0    0 H5I_DATASET         2   FLOAT H5T_IEEE_F32LE SIMPLE    2
    ## 26      0    0 H5I_DATASET         1  STRING     HST_STRING SIMPLE    1
    ## 27      0    0 H5I_DATASET         5   FLOAT H5T_IEEE_F32LE SIMPLE    3
    ## 28      0    0 H5I_DATASET         5   FLOAT H5T_IEEE_F32LE SIMPLE    3
    ## 29      0    0 H5I_DATASET         2   FLOAT H5T_IEEE_F32LE SIMPLE    2
    ##                dim          maxdim
    ## 0                1               1
    ## 1                1               1
    ## 2    544 x 578 x 1   544 x 578 x 1
    ## 3    544 x 578 x 1   544 x 578 x 1
    ## 4    544 x 578 x 1   544 x 578 x 1
    ## 5    544 x 578 x 1   544 x 578 x 1
    ## 6    544 x 578 x 1   544 x 578 x 1
    ## 7    544 x 578 x 1   544 x 578 x 1
    ## 8    544 x 578 x 1   544 x 578 x 1
    ## 9                1               1
    ## 10 544 x 578 x 426 544 x 578 x 426
    ## 11               1               1
    ## 12   544 x 578 x 1   544 x 578 x 1
    ## 13               1               1
    ## 14   544 x 578 x 1   544 x 578 x 1
    ## 15               1               1
    ## 16           1 x 1           1 x 1
    ## 17           1 x 1           1 x 1
    ## 18   544 x 578 x 1   544 x 578 x 1
    ## 19   544 x 578 x 1   544 x 578 x 1
    ## 20   544 x 578 x 1   544 x 578 x 1
    ## 21               1               1
    ## 22         5732053         5732053
    ## 23         5732053         5732053
    ## 24         5732053         5732053
    ## 25         426 x 1         426 x 1
    ## 26               1               1
    ## 27   544 x 578 x 1   544 x 578 x 1
    ## 28   544 x 578 x 1   544 x 578 x 1
    ## 29         426 x 1         426 x 1

    # let's grab some attribute information to use 
    # here we have the CRS information that includes the 
    # UPPER LEFT corner coordinate in UTM (meters)
    mapInfo <- h5read(f,"map info", read.attributes = TRUE)
    mapInfo

    ## [1] "UTM,1,1,325963.0,4103482.0,1.0000000000e+000,1.0000000000e+000,11,North,WGS-84,units=Meters"
    ## attr(,"Description")
    ## [1] "Basic Map information for envi style programs"

## View Wavelengths

Next, let's import some wavelength information.


    # import the center wavelength in um of each "band"
    wavelengths<- h5read(f,"wavelength")

# Grab scale Factor
# notice the data ignore is a character.


    # r  get attributes for the Reflectance dataset
    reflInfo <- h5readAttributes(f,"Reflectance")
    
    # view the scale factor for the data
    reflInfo$`Scale Factor`

    ## [1] 10000

    # view the data ignore value
    reflInfo$`data ignore value`

    ## [1] "15000.0"

    # the data ignore right now is a character (we are fixing this)
    # you have to conver to num or int to ensure it is useful!

# Get shape of reflectance dataset

Let's 
read the data to grab the dimensions.
note: in a future version of the data we will have the dimensions as ATTRIBUTES
that you can automatically pull in


    # open the file for viewing
    fid <- H5Fopen(f)
    # open the reflectance dataset
    did <- H5Dopen(fid, "Reflectance")
    did

    ## HDF5 DATASET
    ## 
    ##         name /Reflectance
    ##     filename 
    ##         type H5T_STD_I16LE
    ##         rank 3
    ##         size 544 x 578 x 426
    ##      maxsize 544 x 578 x 426

    # grab the dimensions of the object
    sid <- H5Dget_space(did)
    dims <- H5Sget_simple_extent_dims(sid)$size
    
    # take note that the data seem to come in ROTATED. wavelength is the 
    # THIRD dimension rather than the first. Columns are the FIRST dimension, then rows.
    # close everything
    H5Sclose(sid)
    H5Dclose(did)
    H5Fclose(fid)

Once we know the dimensions of the data, we can more efficient slice out chunks of it
Let's first grab all of the data for band34


    # if you get an error with the file being "open" just use the generic h5 close below
    # when we are done with our attributes you can skip all of this nonsense :)
    H5close()
    # Extract or "slice" data for band 34 from the HDF5 file
    b56<- h5read(f,"Reflectance", index=list(1:dims[1],1:dims[2],56))
    # note the data come in as an array
    class(b56)

    ## [1] "array"

Next, we will convert the data to a matrix and then to a raster.
We don't need an array because our data are only 2 dimensions at this point (1 single band).


    # Convert from array to matrix so we can plot and convert to a raster
    b56 <- b56[,,1]
    
    # plot the data
    # what happens when we plot?
    image(b56)

![ ]({{ site.baseurl }}/images/rfigs/institute-materials/day1_monday/openNEONH5/view-data-1.png)

    # looks like we need to force a stretch
    image(log(b56), main="band 56 with log transformation")

![ ]({{ site.baseurl }}/images/rfigs/institute-materials/day1_monday/openNEONH5/view-data-2.png)

    # view distribution
    hist(b56)

![ ]({{ site.baseurl }}/images/rfigs/institute-materials/day1_monday/openNEONH5/view-data-3.png)

Ok so now we need to do a few things

1. set the no data value (15000)
2. scale the data by 10000

Let's do that next. 


    noDataVal <- as.integer(reflInfo$`data ignore value`)
    # set all values = 15,000 to NA
    b56[b56 == noDataVal] <- NA
    
    # lets use our scale factor first
    scaleFactor <- reflInfo$`Scale Factor`
    b56 <- b56/scaleFactor
    
    hist(b56, main="distribution with NoData Value considered\nData scaled")

![ ]({{ site.baseurl }}/images/rfigs/institute-materials/day1_monday/openNEONH5/no-data-scale-1.png)


Note -- there are still issues with values over 1. I need to followup with
AOP about how to handle these. 

    # Because the data import column, row but we require row, column in R, 
    # We need to transpose x and y values in order for our final image to plot properly
    b56<-t(b56)
    image(log(b56), main="Transposed image")

![ ]({{ site.baseurl }}/images/rfigs/institute-materials/day1_monday/openNEONH5/transpose-data-1.png)

Next, we need to create the spatial extent required to position the raster in space. 

    # so we can extract the lower left hand corner coordinates.
    # the numbers as position 4 and 5 are the UPPER LEFT CORNER (x,y)
    mapInfo<-unlist(strsplit(mapInfo, ","))
    
    # grab the XY left corner coordinate
    xMin <- as.numeric(mapInfo[4])
    # ensure the format is numeric
    yMax <- as.numeric(mapInfo[5])
    # we can get the x and y resolution from this string too
    res <- c(mapInfo[2],mapInfo[3])
    res <- as.numeric(res)
    
    #  finally calculate the xMAX value and the YMIN value
    # we grabbed the dimensions above. the xmax is the left corner + number of columns* resolution
    xMax <- xMin + (dims[1]*res[1])
    yMin <- yMax - (dims[2]*res[2])
    
    # also note that x and y res are the same (1 meter)
    # Now, define the raster extent
    # define the extent (left, right, top, bottom)
    rasExt <- extent(xMin, xMax,yMin,yMax)
    
    # now we can create a raster and assign it it's spatial extent
    b56r <- raster(b56,
                   crs=CRS("+init=epsg:32611"))
    # assign CRS
    extent(b56r) <- rasExt
    
    # note that the raster flips the data once again.
    # i still need to sort out how to explain this but it has to do with how
    # the raster format nativly is stored.
    b56r

    ## class       : RasterLayer 
    ## dimensions  : 578, 544, 314432  (nrow, ncol, ncell)
    ## resolution  : 1, 1  (x, y)
    ## extent      : 325963, 326507, 4102904, 4103482  (xmin, xmax, ymin, ymax)
    ## coord. ref. : +init=epsg:32611 +proj=utm +zone=11 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 
    ## data source : in memory
    ## names       : layer 
    ## values      : 0.0033, 0.5678  (min, max)

    plot(b56r, main="Raster for Teakettle - B56")

![ ]({{ site.baseurl }}/images/rfigs/institute-materials/day1_monday/openNEONH5/unnamed-chunk-1-1.png)


