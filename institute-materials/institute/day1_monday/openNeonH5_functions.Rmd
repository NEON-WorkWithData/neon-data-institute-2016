---
title: "Open NEON H5 File - Functions"
author: "Leah A. Wasser"
date: "April 28, 2016"
tags: [hdf5]
permalink: /hdf5-r/
output: 
  html_document: 
    theme: readable
---

First, let's load the required libraries.

```{r load-libraries, warning=FALSE, results='hide', message=FALSE}
# load libraries
library(raster)
library(rhdf5)
library(rgdal)

# set wd
setwd("~/Documents/data/1_spectrometerData/Teakettle/testSubset")
# define the CRS definition by EPSG code
epsg <- 32611

# define the file you want to work with
f <- "Subset1NIS1_20130614_095740_atmcor.h5"

```

## Get Reflectance Matrix Dimensions

This function pulls the dimensions of the data from the H5 file. Note: if we had
these as an **NUMERIC** attribute it would be MUCH EASIER to work with.

```{r get-data-dims }

get_data_dims <- function(fileName){
  # make sure everything is closed
  H5close()
  # open the file for viewing
  fid <- H5Fopen(fileName)
  # open the reflectance dataset
  did <- H5Dopen(fid, "Reflectance")
  # grab the dimensions of the object
  sid <- H5Dget_space(did)
  dims <- H5Sget_simple_extent_dims(sid)$size
  
  # close everything
  H5Sclose(sid)
  H5Dclose(did)
  H5Fclose(fid)
  return(dims)
}


```

## Create Spatial Extent Object

Note - once again if the xmin,max and ymin,max were in the H5 file as attributes,
this process would be much easier.

```{r create-function-attrs }

# Create a function that grabs corner coordinates and data res
# and returns an extent object.

create_extent <- function(fileName, dims){
  # Grab upper LEFT corner coordinate from map info dataset 
  mapInfo <- h5read(fileName, "map info")
  # create object with each value in the map info dataset
  mapInfo<-unlist(strsplit(mapInfo, ","))
  # grab the XY left corner coordinate (xmin,ymax)
  xMin <- as.numeric(mapInfo[4])
  yMax <- as.numeric(mapInfo[5])
  # get the x and y resolution
  res <- as.numeric(c(mapInfo[2], mapInfo[3]))
  
  # calculate the xMAX value and the YMIN value
  xMax <- xMin + (dims[1]*res[1])
  yMin <- yMax - (dims[2]*res[2])
  
  # create extent object (left, right, top, bottom)
  rasExt <- extent(xMin, xMax, yMin, yMax)
  # return object of class extent
  return(rasExt)
}


```

## View Wavelengths

View the associated band center in um per band. This is currently a dataset.
It could also be an attribute. I think either way it is OK as long as it's WITH
the reflectance data in the H5 file.

```{r import-wavelength}
# import the center wavelength in um of each "band"
wavelengths<- h5read(f,"wavelength")

```

# Clean Reflectance Data

Notes:

* Currently there are values >1 and a few > 1.5 i think in the data!
* Also note the Nodata value is 15000. using a consistent -9999 could be better.
* If we do this for the no data value, let's please also apply it to the 
RGB imagery and the lidar data.
* note also that i had to create the EPSG code and then make a proj 4 string
it would be IDEAL to have the proj4 string INCLUDED as an attribute along with the
EPSG code please.

That's all for now.
```{r clean-refl-data-fun }
# this function returns a RASTER with no data values
# assigned to NA as required by R and a scale factor applied
# and a shiny new and correct extent / CRS!

clean_refl_data <- function(fileName, reflMatrix, dims, epsg){
  # r  get attributes for the Reflectance dataset
  reflInfo <- h5readAttributes(fileName, "Reflectance")
  # grab noData value
  noData <- as.numeric(reflInfo$`data ignore value`)
  # set all values = 15,000 to NA
  reflMatrix[reflMatrix == noData] <- NA
  
  # apply the scale factor
  reflMatrix <- reflMatrix/(as.numeric(reflInfo$`Scale Factor`))
  
  # now we can create a raster and assign its spatial extent
  reflRast <- raster(reflMatrix,
               crs=CRS(paste0("+init=epsg:", epsg)))
  # finally apply extent to raster, using extent function 
  extent(reflRast) <- create_extent(fileName, dims)
  # return a scaled and "cleaned" raster object
  return(reflRast)
}


```

# Open Band of your choice

I had to use the dims function to grab the dimensions of the matrix. If it were
an attribute that would be much easier to access quickly.

```{r read-refl-data }

open_band <- function(fileName, bandNum, epsg){
  # make sure any open connections are closed
  H5close()
  # you don't necessarily need to get the dims but it's useful
  dims <- get_data_dims(fileName)
  # Extract or "slice" data for band 34 from the HDF5 file
  aBand<- h5read(f, "Reflectance", index=list(1:dims[1],1:dims[2], bandNum))
  # Convert from array to matrix so we can plot and convert to a raster
  aBand <- aBand[,,1]
  # transpose the data to account for columns being read in first
  # but R wants rows first.
  aBand<-t(aBand)
  # clean data
  aBand <- clean_refl_data(fileName, aBand, dims, epsg)
  # return matrix object
  return(aBand)
}
  

```


# Run Actual Code!

### NOTE: might consider grabbing the dimensions of the data first and then
### creating a slice object if you want to grab less than the full extent of the data.

```{r}


### final Code ####
H5close()
# open band, return cleaned and scaled raster
band <- open_band(fileName=f, bandNum = 56, epsg=epsg)
# NOTE: might consider grabbing the dimensions of the data first and then
# creating a slice object if you want to grab less than the full extent of the data.

# plot data
plot(band, 
     main="Raster for Teakettle - B56")

```

# Other notes

1. HDF uses 0 based indexing and also imports cols, rows. R uses 1 based and imports
rows, cols. Thus we have to TRANSPOSE the data. 
Phew, we did it.

?

